{
  "name": "flyd",
  "version": "0.1.0",
  "description": "The less is more, modular, functional reactive programming library",
  "main": "flyd.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "bluebird": "^2.9.13",
    "lodash": "^3.3.1",
    "mocha": "^2.2.1",
    "ramda": "^0.13.0",
    "transducers.js": "^0.2.3"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/paldepind/flyd.git"
  },
  "keywords": [
    "functional",
    "reactive",
    "modular",
    "library"
  ],
  "author": {
    "name": "Simon Friis Vindum"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/paldepind/flyd/issues"
  },
  "homepage": "https://github.com/paldepind/flyd",
  "testling": {
    "harness": "mocha",
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "[![Build Status](https://travis-ci.org/paldepind/flyd.svg?branch=master)](https://travis-ci.org/paldepind/flyd)\n\n# Flyd\nThe modular, KISS, functional reactive programming library for JavaScript.\n\n# Table of contents\n\n* [Introduction](#introduction)\n* [Features](#features)\n* [Examples](#example)\n* [Tutorial](#tutorial)\n* [API](#api)\n* [Modules](#modules)\n\n## Introduction\n\nFunctional reactive programming is a powerful programming paradigm for\nexpressing values that change over time. But existing libraries for JavaScript\nare huge, complex, have a high learning curve and aren't functional enough.\n\nFlyd is simple and expressive. It has a minimal but powerful core on top of\nwhich new abstractions can be built modularly.\n\n## Features\n\n* __Simple and powerful__. Less is more! Flyd provides combineable observable\n  streams as the basic building block. This minimal core is less than 200 SLOC\n  and FRP abstractions can easily be built on top of it.\n* __A more functional style__. Flyd is more functional and less object oriented.\n  Instead of methods it gives you curried functions with arguments in the\n  correct order for partial aplication. This increases the expressive power and\n  the extensibility of the library.\n* Supports the transducer protocol. You can for instance transduce streams with\n  ([Ramda](http://ramdajs.com/).\n* Complies to the [fantasy land](https://github.com/fantasyland/fantasy-land)\n  applicative specification.\n* Elegant support for promises.\n* Atomic updates\n* Easy to extend with custom [modules](#modules)\n\n## Examples\n\n* [Sum](http://paldepind.github.io/flyd/examples/sum/) - very simple example\n* [Multiple clicks](http://paldepind.github.io/flyd/examples/multiple-clicks/)\n  - a remake of the multiple clicks example from \"The introduction to\n  Reactive Programming you've been missing\". Compare it to the [Rx\n  implementation](http://jsfiddle.net/staltz/4gGgs/27/) not quite as elegant.\n* [Secret combination](http://paldepind.github.io/flyd/examples/secret-combination/)\n\nFor other examples check the source code of the [modules](#modules).\n\n## Tutorial\n\n### Creating streams\n\nFlyd gives you streams as the building block for creating reactive dataflows.\nThe function `stream` creates a representation of a value that changes over time.\nA stream is a function and at first sight it works a bit like a getter-setter:\n\n```javascript\n// Create a stream with initial value 5.\nvar number = stream(5);\n// Get the current value of the stream.\nnumber(); // returns 5\n// Update the value of the stream.\nnumber(7); // returns 7\n// The stream now returns the new value.\nnumber(); // returns 7\n```\n\nTop level streams, that is streams without dependencies, should typically\ndepend on the external world, like user input or fetched data.\n\nSince streams are just functions you can easily plug them in whenever a\nfunction is expected.\n\n```javascript\nvar clicks = stream();\ndocument.getElementById('button').addEventListener('click', clicks);\nvar messages = stream();\nwebSocket.onmessage = messages;\n```\n\nClicks events will now flow down the `clicks` stream and WebSockets messages\ndown the `messages` stream.\n\n### Dependent streams\n\nStreams can depend on other streams. Instead of calling `stream` with a value\nas in the above examples we can pass it a list of dependencies and a function.\nThe function should calculate a value based on its dependencies which results\nin a new stream. Flyd automatically updates the stream whenever a dependency\nchanges.\n\nThis means that the `sum` function below will be called whenever `x` and `y` changes.\nYou can think of dependent stream as streams that automatically\nlistens/subscribes to their dependencies.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(4);\nvar y = stream(6);\n// Create a stream that depends on the two previous streams\n// and with its value given by the two added together.\nvar sum = stream([x, y], function() {\n  return x() + y();\n});\n// `sum` is automatically recalculated whenever the streams it depends on changes.\nx(12);\nsum(); // returns 18\ny(8);\nsum(); // returns 20\n```\n\nNaturally, a stream with dependencies can depend on other streams with dependencies.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(4);\nvar y = stream(6);\nvar squareX = stream([x], function() {\n  return x() * x();\n});\nvar squareXPlusY([y, doubleX], function() {\n  return y() + doubleX();\n});\nsquareXPlysY(); // returns 22\nx(2);\nsquareXPlysY(); // returns 10\n```\n\nThe body of a dependent stream is called with two streams: itself and the last\nchanged stream on which it depends.\n\n```javascript\n// Create two streams of numbers\nvar x = stream(1);\nvar y = stream(2);\nvar sum = stream([x, y], function(sum, changed) {\n  // The stream can read from itself\n  console.log('Last sum was ' + sum());\n  if (changed) { // On the initial call no stream has changed\n    var changedName = (changed === y ? 'y' : 'x');\n    console.log(changedName + ' changed to ' + changed());\n  }\n  return x() + y();\n});\n```\n\n### Using calback APIs for asynchronous operations\n\nInstead of returning a value a stream can update itself by calling itself. This\nis handy when working with APIs that takes callbacks.\n\n```\nvar urls = stream('/something.json');\nvar responses = stream([urls], function(resp) {\n  makeRequest(urls(), resp);\n});\nstream([responses], function() {\n  console.log('Recieved response!');\n  console.log(responses());\n});\n```\n\nNote that the stream above logging the responses from the server should only be called\nafter an actual response has been recieved (otherwise `responses()` whould return\n`undefined`). Fortunately a streams body will not be called before all of its declared\nstreams has recieved a value.\n\n### Using promises for asynchronous operations\n\nFlyd has inbuilt support for promises. Similairly to how a promise can never be\nresolved with a promise, a promise can never flow down a stream. Instead the\nfulfilled value of the promise will be sent down the stream.\n\n```javascript\nvar urls = stream('/something.json');\nvar responses = stream(function() {\n  return requestPromise(urls());\n});\nstream([responses], function() {\n  console.log('Recieved response!');\n  console.log(responses());\n});\n```\n\n### Mapping over a stream\n\nYou've now seen the basic building block which Flyd provides. Let's see what we\ncan do with it. Lets write a function that takes a stream and a function and\nreturns a new stream with the functin applied to every value emitted by the\nstream. In short, a `map` function.\n\n```javascript\nvar mapStream = functin(f, s) {\n  return stream([s], function() {\n    return f(s());\n  });\n};\n```\n\nWe simply create a new stream dependent on the first stream. We declare\nthe stream as a dependency so that our stream wont return values before\nthe original stream produces its first value.\n\nFlyd includes a similair map function as part of its core.\n\n### Reducing a stream\n\nLets try something else: reducing a stream! It could look like this:\n\n```javascript\nvar reduceStream = function(f, acc, s) {\n  return stream([s], function() {\n    acc = f(acc, s());\n    return acc;\n  });\n};\n```\n\nOur reduce function takes a reducer function, in initial value and a stream.\nEvery time the original stream emit a value we pass it to the reducer along\nwith the accumulator.\n\nFlyd includes a reduce function as part of its core.\n\n### Fin\n\nYou're done! Now, check out the [API](#api) and/or the [examples](#examples).\n\n## API\n\n### flyd.stream\n\nCreates a new stream.\n\n__Arguments__\n  * \\[`dependencies`\\] (array) – The streams on which this stream should initially depend.\n  * `body` (function|\\*) – The function body of the stream or it initial value.\n  * \\[`staticDependencies`\\] – Disables automatic dependency resolution of the stream.\n\n__Returns__\n\nThe created stream.\n\n###flyd.map(fn, s)\n\nReturns a new stream consisting of every value from `s` passed through `fn. I.e. `map` creates\na new stream that listens to `s` and applies `fn` to every new value.\n\n__Example__\n```javascript\nvar numbers = stream(0);\nvar squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n```\n\n###flyd.reduce(fn, acc, stream)\n\nCreates a new stream with the results of calling the function on every incoming\nstream with and accumulator and the incoming value.\n\n__Example__\n```javascript\nvar numbers = stream();\nvar sum = flyd.reduce(function(sum, n) { return sum+n; }, 0, numbers);\nnumbers(2)(3)(5);\nsum(); // 10\n```\n\n###flyd.merge(stream1, stream2)\n\nCreates a new stream down which all values from both `stream1` and `stream2`\nwill be sent.\n\n__Example__\n```javascript\nvar btn1Clicks = stream();\nbutton1Elm.addEventListener(clicks);\nvar btn2Clicks = stream();\nbutton2Elm.addEventListener(clicks);\nvar allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n```\n\n### flyd.transduce(transducer, stream)\n\nCreates a new stream resulting from applying `transducer` to `stream`.\n\n__Example__\n\n```javascript\nvar t = require('transducers.js');\n\nvar results = [];\nvar s1 = stream();\nvar tx = t.compose(\n  t.map(function(x) { return x * 2; }),\n  t.dedupe()\n);\nvar s2 = flyd.transduce(tx, s1);\nstream([s2], function() { results.push(s2()); });\ns1(1)(1)(2)(3)(3)(3)(4);\nresult; // [2, 4, 6, 8]\n```\n\n###flyd.destroy(stream)\n\nIf the stream has no dependencies this will detach it from any streams it\ndepends on. This makes it available for garbage collection if there are no\nadditional references to it.\n\n###flyd.curryN(n, fn)\n\nReturns `fn` curried to `n`. Use this function to curry functions exposed by\nmodules for Flyd.\n\n###flyd.isStream(stream)\n\nReturns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n\n###stream()\n\nReturns the last value of the stream.\n\n__Example__\n```javascript\nvar names = stream('Turing');\nnames(); // 'Turing'\nnames('Bohr');\nnames(); // 'Bohr'\n```\n\n###stream(val)\n\nPushes a value down the stream.\n\n###stream.map(f)\n\nReturns a new stream identical to the original exept every\nvalue will be passed through `f`.\n\n###stream1.ap(stream2)\n\n`stream1` must be a stream of functions.\n\nReturns a new stream which is the result of applying the\nfunctions from `stream1` to the values in `stream2`.\n\n###stream.of(value)\n\nReturns a new stream with `value` as its initial value.\n\n\n### Modules\n\n* [flyd-filter](https://github.com/paldepind/flyd-filter)\n* [flyd-lift](https://github.com/paldepind/flyd-lift)\n* [flyd-flatmap](https://github.com/paldepind/flyd-flatmap)\n* [flyd-keepwhen](https://github.com/paldepind/flyd-keepwhen)\n* [flyd-sampleon](https://github.com/paldepind/flyd-sampleon)\n",
  "readmeFilename": "README.md",
  "gitHead": "77bac9f6afaf3f631d6714de93404182f4d4e111",
  "_id": "flyd@0.1.0",
  "_shasum": "7dfde25b5b63722bf0b95de2ec56e94fe9d8acf2",
  "_from": "flyd@>=0.1.0 <0.2.0"
}
